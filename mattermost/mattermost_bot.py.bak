import os
import json
import requests
from flask import Flask, request, jsonify
from dotenv import load_dotenv
import logging
import threading
import time
from threading import Event
import websocket
import ssl

# Configure logging to show more details
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(dotenv_path='mattermost/.env')

app = Flask(__name__)

# Mattermost configuration
MATTERMOST_URL = os.getenv('MATTERMOST_URL')
BOT_TOKEN = os.getenv('BOT_TOKEN')
BOT_USERNAME = os.getenv('BOT_USERNAME', 'knowledge-agent')  
BOT_ICON_URL = os.getenv('BOT_ICON_URL', 'https://example.com/bot-icon.png')

HEADERS = {
    'Authorization': f'Bearer {BOT_TOKEN}',
    'Content-Type': 'application/json'
}

# Add health endpoint
@app.route('/health')
def health_check():
    return jsonify({
        'status': 'healthy',
        'mattermost_connected': MATTERMOST_URL is not None,
        'bot_token_set': BOT_TOKEN is not None
    })

def connect_websocket():
    """Connect to Mattermost WebSocket"""
    ws_url = MATTERMOST_URL.replace('http', 'ws') + '/api/v4/websocket'
    logger.info(f"Connecting to WebSocket: {ws_url}")
    
    def on_message(ws, message):
        logger.debug(f"WebSocket message received: {message}")

    def on_error(ws, error):
        logger.error(f"WebSocket error: {error}")

    def on_close(ws, close_status_code, close_msg):
        logger.info("WebSocket connection closed")
        time.sleep(5)  # Wait before reconnecting
        connect_websocket()  # Reconnect

    def on_open(ws):
        logger.info("WebSocket connection established")
        # Authenticate with the WebSocket
        auth_message = {
            "seq": 1,
            "action": "authentication_challenge",
            "data": {
                "token": BOT_TOKEN
            }
        }
        ws.send(json.dumps(auth_message))

    websocket.enableTrace(True)
    ws = websocket.WebSocketApp(
        ws_url,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
        on_open=on_open,
        header=HEADERS
    )
    
    wst = threading.Thread(target=ws.run_forever, kwargs={
        'sslopt': {"cert_reqs": ssl.CERT_NONE}
    })
    wst.daemon = True
    wst.start()

# Start WebSocket connection in a separate thread
connect_websocket()

def send_message(channel_id, message, response_type='in_channel', root_id=None):
    """Send a message to a Mattermost channel
    
    Args:
        channel_id: The ID of the channel to send the message to
        message: The message content
        response_type: The type of response ('in_channel' or 'ephemeral')
        root_id: The ID of the root post to reply to (for creating/continuing a thread)
    """
    headers = {
        'Authorization': f'Bearer {BOT_TOKEN}',
        'Content-Type': 'application/json'
    }
    
    payload = {
        'channel_id': channel_id,
        'message': message,
        'props': {
            'from_webhook': 'true',
            'override_username': BOT_USERNAME,
            'override_icon_url': BOT_ICON_URL
        }
    }
    
    # Add root_id to payload if provided to create/continue a thread
    if root_id:
        logger.info(f"Creating thread reply - root_id: {root_id}")
        payload['root_id'] = root_id
        logger.info(f"Full payload for thread reply: {json.dumps(payload, indent=2)}")
    else:
        logger.info("Creating new message (no thread)")
    
    try:
        logger.info(f"Sending message to channel {channel_id}")
        response = requests.post(
            f'{MATTERMOST_URL}/api/v4/posts',
            headers=headers,
            json=payload
        )
        response.raise_for_status()
        
        # Log the response for debugging
        response_data = response.json()
        logger.info(f"Mattermost API response: {json.dumps(response_data, indent=2)}")
        
        if 'id' in response_data:
            if root_id:
                logger.info(f"Successfully created thread reply - Message ID: {response_data['id']}, Thread ID: {root_id}")
            else:
                logger.info(f"Successfully created new message - ID: {response_data['id']}")
        
        return response_data
    except Exception as e:
        logger.error(f"Error sending message to Mattermost: {str(e)}")
        raise

def show_typing(channel_id):
    """Show typing indicator in a Mattermost channel"""
    headers = {
        'Authorization': f'Bearer {BOT_TOKEN}',
        'Content-Type': 'application/json'
    }
    
    try:
        response = requests.post(
            f'{MATTERMOST_URL}/api/v4/users/me/typing',
            headers=headers,
            json={'channel_id': channel_id}
        )
        response.raise_for_status()
        return response.json() if response.content else None
    except Exception as e:
        logger.error(f"Error showing typing indicator: {str(e)}")
        return None

def show_typing_continuous(channel_id, stop_event):
    """Show typing indicator continuously until stop_event is set"""
    while not stop_event.is_set():
        try:
            response = requests.post(
                f'{MATTERMOST_URL}/api/v4/users/me/typing',
                headers=HEADERS,
                json={'channel_id': channel_id}
            )
            response.raise_for_status()
            time.sleep(5)  # Show typing indicator every 5 seconds
        except Exception as e:
            logger.error(f"Error showing typing indicator: {e}")
            break

def process_query(text, channel_id, user_name, root_id=None):
    """Process a query through the RAG pipeline"""
    try:
        # Create a stop event for the typing indicator thread
        stop_typing = threading.Event()
        
        # Start the typing indicator in a separate thread
        typing_thread = threading.Thread(
            target=show_typing_continuous,
            args=(channel_id, stop_typing)
        )
        typing_thread.daemon = True
        typing_thread.start()

        try:
            # Log the request we're about to make
            request_data = {'text': text}
            logger.info(f"Sending request to RAG pipeline: {json.dumps(request_data)}")
            
            # Forward the query to the RAG pipeline with increased timeout
            response = requests.post(
                'http://localhost:5001/query',
                json=request_data,
                headers={'Content-Type': 'application/json'},
                timeout=120
            )
            
            # Log the raw response
            logger.info(f"Raw response from RAG pipeline: {response.text}")
            
            # Check if the response was successful
            response.raise_for_status()
            
            # Parse the response
            response_data = response.json()
            
            # Stop the typing indicator
            stop_typing.set()
            typing_thread.join(timeout=1)
            
            # Extract the answer from the response
            answer = response_data.get('response', 'I apologize, but I was unable to process your query.')
            
            # Send the response back to Mattermost
            send_message(channel_id, answer, root_id=root_id)
            
            return jsonify({'response_type': 'in_channel'})
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Error making request to RAG pipeline: {str(e)}")
            error_message = "I apologize, but I'm having trouble processing your request right now. Please try again in a moment."
            send_message(channel_id, error_message, root_id=root_id)
            return jsonify({'response_type': 'in_channel'})
            
        finally:
            # Ensure typing indicator is stopped
            stop_typing.set()
            if typing_thread.is_alive():
                typing_thread.join(timeout=1)
                
    except Exception as e:
        logger.error(f"Unexpected error in process_query: {str(e)}")
        error_message = "I apologize, but an unexpected error occurred. Please try again later."
        send_message(channel_id, error_message, root_id=root_id)
        return jsonify({'response_type': 'in_channel'})

@app.route('/test', methods=['GET'])
def test():
    return "Bot is running!"

@app.route('/mattermost', methods=['POST'])
def mattermost_webhook():
    try:
        data = request.get_json()
        if not data:
            logger.error("No JSON data received in webhook request")
            return jsonify({'error': 'No data provided'}), 400

        channel_id = data.get('channel_id', '')
        user_name = data.get('user_name', 'user')
        
        # Handle mentions (from outgoing webhook)
        if 'text' in data:
            message = data.get('text', '').strip()
            logger.info(f"Received message: '{message}'")
            
            # Check if this is a mention
            if f"@{BOT_USERNAME}" in message:
                # Get the actual command/query (everything after the mention)
                parts = message.split(None, 2)  # Split into max 3 parts
                logger.info(f"Message parts: {parts}")
                
                if len(parts) > 1:  # We have a command after the mention
                    # The command will be the second part (after @username)
                    command = parts[1].lower() if len(parts) > 1 else ''
                    logger.info(f"Extracted command: '{command}'")

                    # Handle help command
                    if command == 'help':
                        logger.info("Processing help command")
                        help_message = """:wave: Hi! I'm your knowledge assistant. Ask me anything!

You can interact with me by:

Mention me: @knowledge-agent your question here
Examples:

@knowledge-agent Can you explain the difference between X and Y?"""
                        send_message(channel_id, help_message)
                        return jsonify({'response_type': 'in_channel'})

                    # Handle greetings
                    if command in ['hi', 'hello', 'hey', 'greetings']:
                        logger.info("Processing greeting command")
                        greeting_message = f"Hello {user_name}! How can I help you today? :smile:"
                        send_message(channel_id, greeting_message)
                        return jsonify({'response_type': 'in_channel'})

                    # For other queries, get the full text after the command
                    query = ' '.join(parts[1:]) if len(parts) > 1 else ''
                    logger.info(f"Processing regular query: '{query}'")

                    # Get post_id for threading regular responses
                    post_id = None
                    if 'post' in data:
                        try:
                            if isinstance(data['post'], str):
                                post_data = json.loads(data['post'])
                            else:
                                post_data = data['post']
                            post_id = post_data.get('id')
                        except json.JSONDecodeError as e:
                            logger.error(f"Error parsing post data: {e}")
                    
                    if post_id is None:
                        post_id = data.get('trigger_id') or data.get('post_id')

                    # Process as regular query
                    return process_query(query, channel_id, user_name, post_id)
        
        # Handle slash command
        elif 'command' in data:
            text = data.get('text', '').strip()
            logger.info(f"Processing slash command with text: {text}")
            post_id = data.get('trigger_id') or data.get('post_id')
            return process_query(text, channel_id, user_name, post_id)
            
        return jsonify({'response_type': 'ephemeral'})

    except Exception as e:
        error_message = f"Error processing webhook: {str(e)}"
        logger.error(error_message)
        logger.exception("Full exception details:")
        return jsonify({'text': error_message, 'response_type': 'ephemeral'})

def handle_lecture_command(data):
    """Handle /lecture command"""
    try:
        # Extract channel_id and text from the data
        channel_id = data.get('channel_id')
        text = data.get('text', '').strip()
        
        if not text:
            send_message(channel_id, "Please provide a query after the /lecture command.")
            return
            
        logger.info(f"Processing lecture query: {text}")
        
        # Create a stop event for the typing indicator
        stop_typing = Event()
        
        # Start typing indicator in a separate thread
        typing_thread = threading.Thread(
            target=show_typing_continuous,
            args=(channel_id, stop_typing)
        )
        typing_thread.start()
        
        try:
            # Make request to RAG pipeline
            response = requests.post(
                'http://localhost:5001/query',
                json={'text': text},
                timeout=120
            )
            response.raise_for_status()
            result = response.json()
            
            # Format and send the response
            answer = result.get('answer', 'No answer found')
            send_message(channel_id, answer)
            
        except requests.Timeout:
            send_message(channel_id, "The query took too long to process. Please try again with a simpler query.")
        except requests.RequestException as e:
            logger.error(f"Error making request to RAG pipeline: {e}")
            send_message(channel_id, "Sorry, there was an error processing your query. Please try again later.")
        finally:
            # Stop the typing indicator
            stop_typing.set()
            typing_thread.join()
            
    except Exception as e:
        logger.error(f"Error handling lecture command: {e}")
        if channel_id:
            send_message(channel_id, "Sorry, there was an error processing your command.")

if __name__ == '__main__':
    # Verify environment variables
    required_vars = ['MATTERMOST_URL', 'BOT_TOKEN']
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        raise ValueError(f"Missing required environment variables: {', '.join(missing_vars)}")
    
    # Start the Flask app
    app.run(host='0.0.0.0', port=5002) 